"""Generated by deepseek-r1v3"""

import socket
import time
import subprocess
import os
from utils.log import LogE, LogD, LogI, LogS
from configuration import *

class LowLatencyController:
  def __init__(self, adb_path="adb", device="127.0.0.1:7555", remote_port=12345):
    self.adb_path = adb_path
    self.device = device
    self.remote_port = remote_port
    self.socket = None
    self.latency_stats = []
  
  def _connect(self, max_retries=3):
    for attempt in range(max_retries):
      try:
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置socket选项以减少延迟
        self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)  # 禁用Nagle算法
        self.socket.settimeout(5.0)
        self.socket.connect(('127.0.0.1', self.remote_port))
        return True
      except Exception as e:
        LogE(f"Connection attempt {attempt + 1} failed: {e}")
        if self.socket:
            self.socket.close()
            self.socket = None
        time.sleep(0.1 * (attempt + 1))  # 递增重试延迟
    return False
  
  def connect(self):
    while True:
      try:
        if not self._connect(): LogE("Failed to connect after retries"); exit(1)
        self.send_cmd("p")
        rp = self.recv()
        if rp == CONTROLLER_READY_HASH: break
      except Exception as e:
        LogI(f"Test connection failed: {e}")
      time.sleep(1.0)
    LogI("Connected to 'bangcheater'")
  
  def send_cmd(self, command):
    if not self.socket: return False
    if not command.endswith('\n'): command += '\n'
    # 发送命令
    self.socket.sendall(command.encode('utf-8'))
    return True
    
  def recv(self, recv_timeout:int=RECV_TIMEOUT):
    # 接收响应（带超时）
    try:
      self.socket.settimeout(recv_timeout)
      response = self.socket.recv(1024).decode('utf-8').strip()
    except socket.timeout:
      LogE(f"Receive timeout ({recv_timeout}s)")
      raise socket.timeout
    return response
  
  def start_bangcheater(
    self,
    remote_path="/data/local/tmp/bangcheater",
    commands_path="./data/local/tmp/commands.sheet"
  ):
      try:
        # 让 adb 连接
        connect_cmd = [self.adb_path, "connect", self.device]
        os.system(' '.join(connect_cmd))
        LogI(f"controller connect to {self.device}")
        
        # 移除可能存在的旧端口转发
        remove_cmd = [self.adb_path, "-s", self.device, "forward", "--remove", f"tcp:{self.remote_port}"]
        os.system(' '.join(remove_cmd))
        LogI("controller remove old forward tcp")
        
        # 设置新的端口转发
        forward_cmd = [self.adb_path, "-s", self.device, "forward", f"tcp:{self.remote_port}", f"tcp:{self.remote_port}"]
        result = os.system(' '.join(forward_cmd))
        LogI(f"controller establish new forward, code:{result}")
        
        self.kill_bangcheater()
        LogI("controller kill old 'bangcheater'")
        
        start_cmd = [self.adb_path, "-s", self.device, "shell", f"{remote_path}", f"{commands_path}", "-t"]
        self.p = subprocess.Popen(start_cmd, stdin=subprocess.PIPE, stdout=subprocess.DEVNULL)
        LogI("controller start new 'bangcheater'")
        
        # 等待服务启动
        timeout = 3
        start_time = time.time()
        while time.time() - start_time < timeout:
          if self.p.poll() is None:
            LogI("'bangcheater' started")
            return True
        return False
          
      except subprocess.CalledProcessError as e:
        LogE(f"controller failed to start BangCheater: {e}")
        return False
  
  def kill_bangcheater(self):
    kill_cmd = [self.adb_path, "-s", self.device, "shell", "pkill", "-f", "bangcheater"]
    result = os.system(' '.join(kill_cmd))
    
  def __del__(self): self.cleanup()
  def cleanup(self):
    if self.socket:
      try: self.send_cmd("e")
      except: pass
      self.socket.close()
    try:
      remove_cmd = [self.adb_path, "-s", self.device, "forward", "--remove", f"tcp:{self.remote_port}"]
      subprocess.run(remove_cmd, capture_output=True)
    except: pass

def click(x, y):
  global clr
  clr.send_cmd('d 0 %d %d\n'%(x,y))
  time.sleep(TCP_SEND_GAP)
  clr.send_cmd('c\n')
  time.sleep(0.05)
  clr.send_cmd('u\n')
  time.sleep(TCP_SEND_GAP)
  clr.send_cmd('c\n')

if __name__ == "__main__":
  clr = LowLatencyController(
    adb_path="adb",
    device=f"127.0.0.1:{MUMU_PORT}",
    remote_port=BANGCHEATER_PORT
  )
  try:
    
    # 启动bangcheater
    clr.start_bangcheater()
    time.sleep(0.0)
    # 连接
    clr.connect()
    
    # 通信
    clr.send_cmd("f")
    
    while True:
      cmd = input("type cmd:\n")
      x, y = cmd.split(' ')
      click(int(x), int(y))
      
  finally:
    clr.cleanup()