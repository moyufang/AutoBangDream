"""Generated by deepseek-r1v3"""

import socket
import time
import subprocess
import os
from utils.log import LogE, LogD, LogI, LogS

CONTROLLER_READY_HASH = "BANGCHEATERCONTROLLERREADY"
RECV_TIMEOUT = 0.5

class LowLatencyController:
  def __init__(self, adb_path="adb", device="127.0.0.1:7555", local_port=12345):
    self.adb_path = adb_path
    self.device = device
    self.local_port = local_port
    self.remote_port = 12345
    self.socket = None
    self.latency_stats = []
  
  def _connect(self, max_retries=3):
    for attempt in range(max_retries):
      try:
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置socket选项以减少延迟
        self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)  # 禁用Nagle算法
        self.socket.settimeout(5.0)
        self.socket.connect(('127.0.0.1', self.local_port))
        return True
      except Exception as e:
        LogE(f"Connection attempt {attempt + 1} failed: {e}")
        if self.socket:
            self.socket.close()
            self.socket = None
        time.sleep(0.1 * (attempt + 1))  # 递增重试延迟
    return False
  
  def connect(self):
    while True:
      try:
        if not self._connect(): LogE("Failed to connect after retries"); exit(1)
        self.send_command_low_latency("p")
        rp = self.recv()
        if rp == CONTROLLER_READY_HASH: break
      except Exception as e:
        LogI(f"Test connection failed: {e}")
      time.sleep(1.0)
    LogI("Connected to 'bangcheater'")
  
  def send_command_low_latency(self, command):
    if not self.socket: return False
    try:
      if not command.endswith('\n'): command += '\n'
      
      # 发送命令
      self.socket.sendall(command.encode('utf-8'))
      send_time = time.time()
      
    except socket.timeout:
      print(f"Command timeout: {command.strip()}")
      return False
    except Exception as e:
      print(f"Command failed: {e}")
      return False
    
  def recv(self):
    # 接收响应（带超时）
    try:
      self.socket.settimeout(RECV_TIMEOUT)
      response = self.socket.recv(1024).decode('utf-8').strip()
    except socket.timeout:
      LogE(f"Receive timeout ({RECV_TIMEOUT}s)")
      raise socket.timeout
    return response
  
  def start_bangcheater(
    self,
    remote_path="/data/local/tmp/bangcheater",
    commands_path="./data/local/tmp/commands.sheet"
  ):
      try:
        # 让 adb 连接
        connect_cmd = [self.adb_path, "connect", self.device]
        os.system(' '.join(connect_cmd))
        LogI("controller connect to 127.0.0.1:7555")
        
        # 移除可能存在的旧端口转发
        remove_cmd = [self.adb_path, "-s", self.device, "forward", "--remove", f"tcp:{self.local_port}"]
        os.system(' '.join(remove_cmd))
        LogI("controller remove old forward tcp:1234")
        
        # 设置新的端口转发
        forward_cmd = [self.adb_path, "-s", self.device, "forward", f"tcp:{self.local_port}", f"tcp:{self.remote_port}"]
        result = os.system(' '.join(forward_cmd))
        LogI(f"controller establish new forward, code:{result}")
        
        kill_cmd = [self.adb_path, "-s", self.device, "shell", "pkill", "-f", "bangcheater"]
        result = os.system(' '.join(kill_cmd))
        LogI("controller kill old 'bangcheater'")
        
        start_cmd = [self.adb_path, "-s", self.device, "shell", f"{remote_path}", f"{commands_path}", "-t"]
        self.p = subprocess.Popen(start_cmd, stdin=subprocess.PIPE, stdout=subprocess.DEVNULL)
        LogI("controller start new 'bangcheater'")
        
        # 等待服务启动
        timeout = 3
        start_time = time.time()
        while time.time() - start_time < timeout:
          if self.p.poll() is None:
            LogI("'bangcheater' started")
            return True
        return False
          
      except subprocess.CalledProcessError as e:
        LogE(f"controller failed to start BangCheater: {e}")
        return False
      
  # def run_commands(self, cmd):
  #   results = []
    
  #   start_time = time.time()
  #   response = self.send_command_low_latency(cmd)
  #   end_time = time.time()
    
  #   if response:
  #     latency = (end_time - start_time) * 1000
  #     results.append(f"{cmd} -> {response} ({latency:.1f}ms)")
  #     LogD(f"Executed: {cmd} -> {response} ({latency:.1f}ms)")
  #   else:
  #     results.append(f"{cmd} -> FAILED")
  #     LogD(f"Failed: {cmd}")
  #   return results[0]
          
  def cleanup(self):
    if self.socket:
      try: self.send_command_low_latency("QUIT", expect_response=False)
      except: pass
      self.socket.close()
      
    # 移除ADB转发
    try:
      remove_cmd = [self.adb_path, "-s", self.device, "forward", "--remove", f"tcp:{self.local_port}"]
      subprocess.run(remove_cmd, capture_output=True)
    except: pass

TCP_SEND_GAP = 0.005

def click(x, y):
  global clr
  clr.send_command_low_latency('d 0 %d %d\n'%(x,y))
  time.sleep(TCP_SEND_GAP)
  clr.send_command_low_latency('c\n')
  time.sleep(0.05)
  clr.send_command_low_latency('u\n')
  time.sleep(TCP_SEND_GAP)
  clr.send_command_low_latency('c\n')

if __name__ == "__main__":
  clr = LowLatencyController(
    adb_path="adb",
    device="127.0.0.1:7555",
    local_port=12345
  )
  try:
    
    # 启动bangcheater
    clr.start_bangcheater()
    time.sleep(0.0)
    # 连接
    clr.connect()
    
    # 通信
    clr.send_command_low_latency("f")
    
    while True:
      cmd = input("type cmd:\n")
      x, y = cmd.split(' ')
      click(int(x), int(y))
      
  finally:
    clr.cleanup()